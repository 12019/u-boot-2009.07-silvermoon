#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#if defined(__linux__)
#include <stdint.h>
#else
#ifdef __CYGWIN__
#include "elf.h"
#else
#include <inttypes.h>
#endif
#endif

unsigned char *rgb_data=NULL;
static int flip_rgb_data(int width, int height, unsigned char *rgb);

typedef struct bitmap_s {		/* bitmap description */
	uint16_t width;
	uint16_t height;
	uint8_t	palette[256*3];
	uint8_t	*data;
} bitmap_t;

#define DEFAULT_CMAP_SIZE	16	/* size of default color map	*/

// Optional binary output file to write raw flipped data to
static int g_binary_output = 0;

/*
 * Neutralize little endians.
 */
uint16_t le_short(uint16_t x)
{
    uint16_t val;
    uint8_t *p = (uint8_t *)(&x);

    val =  (*p++ & 0xff) << 0;
    val |= (*p & 0xff) << 8;

    return val;
}

void skip_bytes (FILE *fp, int n)
{
	while (n-- > 0)
		fgetc (fp);
}

int main (int argc, char *argv[])
{
	int	i, x;
	FILE	*fp;
	bitmap_t bmp;
	bitmap_t *b = &bmp;
	uint16_t data_offset, n_colors;

	if (argc < 2) {
		fprintf (stderr, "Usage: %s file [output.bin]\n", argv[0]);
		exit (EXIT_FAILURE);
	}

	if ((fp = fopen (argv[1], "rb")) == NULL) {
		perror (argv[1]);
		exit (EXIT_FAILURE);
	}

	if (fgetc (fp) != 'B' || fgetc (fp) != 'M') {
		fprintf (stderr, "%s is not a bitmap file.\n", argv[1]);
		exit (EXIT_FAILURE);
	}

	if (argc > 2)
	{
		g_binary_output = open( argv[2], O_RDWR|O_CREAT|O_TRUNC, 0644 );
		if (g_binary_output < 0)
		{
			fprintf( stderr, "Could not open binary output %s\n", argv[2] );
			exit( EXIT_FAILURE );
		}
	}

	/*
	 * read width and height of the image, and the number of colors used;
	 * ignore the rest
	 */
	skip_bytes (fp, 8);
	fread (&data_offset, sizeof (uint16_t), 1, fp);
	skip_bytes (fp, 6);
	fread (&b->width,   sizeof (uint16_t), 1, fp);
	skip_bytes (fp, 2);
	fread (&b->height,  sizeof (uint16_t), 1, fp);
	skip_bytes (fp, 22);
	fread (&n_colors, sizeof (uint16_t), 1, fp);
	skip_bytes (fp, 6);

	/*
	 * Repair endianess.
	 */
	data_offset = le_short(data_offset);
	b->width = le_short(b->width);
	b->height = le_short(b->height);
	n_colors = le_short(n_colors);

	i = 0;
	/* Seek to data part */
	fseek(fp, (long)data_offset, SEEK_SET);
	rgb_data = (unsigned char *)malloc( b->width*b->height*3);
	if(rgb_data == NULL) {
		printf("Failed to allocate memory\n");
		exit (EXIT_FAILURE);
	}

	/* Store the raw BMP data */
	while((x=getc(fp)) != EOF) {
		rgb_data[i++] = x;
	}

	printf ("/*\n"
		" * Automatically generated by \"tools/bmp_logo\" from %s (%dx%d)\n"
		" *\n"
		" * DO NOT EDIT\n"
		" *\n"
		" */\n\n\n"
		"#ifndef __BMP_LOGO_H__\n"
		"#define __BMP_LOGO_H__\n\n"
		"\n", argv[1], b->width, b->height );

	printf( "#define BMP_LOGO_BYTES	%d\n", i );
	printf( "#define BMP_LOGO_WIDTH %d\n", b->width );
	printf( "#define BMP_LOGO_HEIGHT %d\n", b->height );
	printf ("unsigned char bmp_logo_bitmap[] = {\n");
	/* Invert/flip the BMP file */
	flip_rgb_data(b->width, b->height, rgb_data);

	printf ("\n"
		"};\n\n"
		"#endif /* __BMP_LOGO_H__ */\n"
	);
	fclose(fp);

	if (g_binary_output > 0)
	{
		close( g_binary_output );
		g_binary_output = 0;
	}

	return (0);
}

int flip_rgb_data(int width, int height, unsigned char *rgb)
{
    int i, k, j, ipos, index=0;
    int bytesPerLine;
    unsigned char *line;
    int bytes_per_pixel = 2;

    /* The length of each line must be a multiple of 4 bytes */
    bytesPerLine = (bytes_per_pixel * (width + 1) / 4) * 4;

    line = malloc(bytesPerLine);
    if (line == NULL) {
        fprintf(stderr, "Can't allocate memory for BMP file.\n");
        exit(EXIT_FAILURE);
    }

    for (i = height - 1; i >= 0; i--) {
        for (j = 0; j < width; j++) {
            ipos = bytes_per_pixel * (width * i + j);
            for (k = 0; k < bytes_per_pixel; k++)
            {
				line[bytes_per_pixel*j+k] = rgb[ipos + k];
            }
        }
        if (g_binary_output > 0)
        {
        	if (write( g_binary_output, line, bytes_per_pixel * width ) != bytes_per_pixel * width)
        	{
        		fprintf( stderr, "Failed to write to binary, errno=%d\n", errno );
        		exit( -1 );
        	}
        }
		for(k=0; k<bytesPerLine;k++) {
			if ((index%8) == 0) putchar ('\t');
			printf ("0x%02X,%c", line[k], ((index%8) == 7) ? '\t' : ' ');
			if((index%16) == 15) putchar('\n');
			index++;
		}
    }

    free(line);

    return(0);
}
